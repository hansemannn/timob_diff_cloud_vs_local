"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _crypto = _interopRequireDefault(require("crypto"));

var _fsExtra = _interopRequireDefault(require("fs-extra"));

var _os = _interopRequireDefault(require("os"));

var _path = _interopRequireDefault(require("path"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Titanium Cloak
 *
 * @copyright
 * Copyright (c) 2019 by Axway, Inc. All Rights Reserved.
 *
 * @license
 * This code is closed source.
 * Confidential and Proprietary to Axway, Inc. All Rights Reserved.
 */
const PLATFORM = _os.default.platform();

const ARCH = _os.default.arch();

const NODE_MAJOR = parseInt(process.versions.node); // Validate minimum node version requirement.

if (NODE_MAJOR < 8) {
  throw new Error('Invalid node version, must use 8.0.0 or above.');
}

let Binding;

try {
  // Attempt to load NAPI native module first.
  Binding = require(`./native/ti.cloak-${PLATFORM}-${ARCH}.node`);
} catch (e) {
  // Could not load NAPI module, try compatibility module.
  Binding = require(`./native/ti.cloak-${PLATFORM}-${ARCH}-v${NODE_MAJOR}.node`);
} finally {
  if (!Binding) {
    throw new Error(`Could not load 'ti.cloak' native module.`);
  }
}

class Cloak {
  /**
   * @param {Buffer} [key] Key to use for encryption.
   * @param {Buffer} [salt] Salt to use for encryption.
   *
   * If the `key` and `salt` are not provided, they will be randomly generated.
   */
  constructor(key, salt) {
    this.key = key || _crypto.default.randomBytes(16);
    this.salt = salt || _crypto.default.randomBytes(16);
  }
  /**
   * Encrypt data asynchronously.
   *
   * @param {Buffer} data Source file to encrypt.
   * @returns {Promise} With encrypted data as parameter.
   */


  async encrypt(data) {
    // NOTE: there currently are no async crypto APIs.
    return this.encryptSync(data);
  }
  /**
   * Encrypt data synchrounusly.
   *
   * @param {Buffer} data Source file to encrypt.
   * @return {Buffer} Encrypted data.
   */


  encryptSync(data) {
    if (typeof data === 'string') {
      data = Buffer.from(data, 'utf8');
    }

    const cipher = _crypto.default.createCipheriv('aes-128-cbc', this.key, this.salt);

    const output = Buffer.concat([cipher.update(data), cipher.final()]);
    return output;
  }
  /**
   * Encrypt file asynchronously.
   *
   * @param {string} source Source file to encrypt.
   * @param {string} destination Destination encrypted file will be output.
   * @returns {Promise}
   */


  async encryptFile(source, destination) {
    const data = await _fsExtra.default.readFile(source);
    const output = await this.encrypt(data);
    return _fsExtra.default.writeFile(destination, output);
  }
  /**
   * Encrypt file synchronously.
   *
   * @param {string} source Source file to encrypt.
   * @param {string} destination Destination encrypted file will be output.
   */


  encryptFileSync(source, destination) {
    const data = _fsExtra.default.readFileSync(source);

    const output = this.encrypt(data);

    _fsExtra.default.writeFileSync(destination, output);
  }
  /**
   * Asynchrounously set key in platform 'ti.cloak' libraries for functioning runtime decryption.
   *
   * @param {string} platform Platform of libraries to process.
   * @param {string[]} archs Array for architectures supported by the platform.
   * @param {string} destination Destination for processed libraries to be stored.
   * @returns {Promise}
   */


  async setKey(platform, archs, destination) {
    if (platform !== 'android') {
      throw new Error(`Invalid platform '${platform}'.`);
    }

    return Promise.all(archs.map(async arch => {
      // Load stub library into buffer.
      const buffer = await _fsExtra.default.readFile(_path.default.join(__dirname, 'android', arch, 'libti.cloak.so')).catch(error => {
        throw new Error(`Could not set key, unable to read stub library for ${arch}.`);
      }); // Inject key info buffer, throws exception upon failure.

      Binding.setKey(buffer, this.key, this.salt); // Write buffer to target destination.

      const target = _path.default.join(destination, arch, 'libti.cloak.so');

      await _fsExtra.default.ensureDir(_path.default.dirname(target)).catch(error => {
        throw new Error(`Could not set key, '${target}' does not exist.`);
      });
      await _fsExtra.default.writeFile(target, buffer).catch(error => {
        throw new Error(`Could not set key, unable to write '${target}'.`);
      });
    }));
  }
  /**
   * Synchrounously set key in platform 'ti.cloak' libraries for functioning runtime decryption.
   *
   * @param {string} platform Platform of libraries to process.
   * @param {string[]} archs Array for architectures supported by the platform.
   * @param {string} destination Destination for processed libraries to be stored.
   */


  setKeySync(platform, archs, destination) {
    if (platform === 'android') {
      for (const arch of archs) {
        // Load stub library into buffer and set key, throws exception upon failure.
        const buffer = _fsExtra.default.readFileSync(_path.default.join(__dirname, 'android', arch, 'libti.cloak.so'));

        Binding.setKey(buffer, this.key, this.salt); // Write buffer to target destination.

        const target = _path.default.join(destination, arch, 'libti.cloak.so');

        _fsExtra.default.ensureDirSync(_path.default.dirname(target));

        _fsExtra.default.writeFileSync(target, buffer);
      }
    }
  }

}

exports.default = Cloak;